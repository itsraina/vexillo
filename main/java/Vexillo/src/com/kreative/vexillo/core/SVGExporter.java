package com.kreative.vexillo.core;

import java.awt.BasicStroke;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.Line2D;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import com.kreative.vexillo.core.Color.HasRGB;

public class SVGExporter {
	private static final int CLIP_ID = 0;
	private static final int GRAD_ID = 1;
	private static final int NEXT_ID = 2;
	
	private final File flagFile;
	private final File parent;
	private final Flag flag;
	private final boolean embeddedMode;
	private final int tx, ty;
	private final Map<String, String> imageCache;
	
	public SVGExporter(File flagFile, File parent, Flag flag) {
		this(flagFile, parent, flag, false, 0, 0);
	}
	
	public SVGExporter(File flagFile, File parent, Flag flag, boolean embeddedMode, int tx, int ty) {
		this.flagFile = flagFile;
		this.parent = parent;
		this.flag = flag;
		this.embeddedMode = embeddedMode;
		this.tx = tx;
		this.ty = ty;
		this.imageCache = new HashMap<String, String>();
	}
	
	public File getFlagFile() { return flagFile; }
	public File getParentFile() { return parent; }
	public Flag getFlag() { return flag; }
	
	public String exportToString(int w, int h, int glaze) {
		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw, true);
		export(pw, w, h, glaze);
		pw.flush();
		pw.close();
		return sw.getBuffer().toString();
	}
	
	public void export(File out, int w, int h, int glaze) throws IOException {
		FileOutputStream fos = new FileOutputStream(out);
		OutputStreamWriter osw = new OutputStreamWriter(fos, "UTF-8");
		PrintWriter pw = new PrintWriter(osw, true);
		export(pw, w, h, glaze);
		pw.flush();
		pw.close();
	}
	
	public void export(PrintWriter out, int w, int h, int glaze) {
		Map<String, Dimension> d = flag.createNamespace(h, w);
		List<String> styleBlock = new LinkedList<String>();
		List<String> defsBlock = new LinkedList<String>();
		List<String> groupBlock = new LinkedList<String>();
		List<String> glazeBlock = new LinkedList<String>();
		int[] next = new int[NEXT_ID];
		
		if (embeddedMode) {
			defsBlock.add("<clipPath id=\"bounds\">");
			defsBlock.add("<rect x=\"0\" y=\"0\" width=\"" + w + "\" height=\"" + h + "\"/>");
			defsBlock.add("</clipPath>");
		}
		prep(styleBlock, defsBlock);
		for (Instruction i : flag.instructions()) execute(i, d, defsBlock, groupBlock, next, false);
		if (glaze > 0) glaze(d, defsBlock, glazeBlock, w, h, glaze);
		
		if (!embeddedMode) out.println("<?xml version=\"1.0\"?>");
		out.print("<svg");
		if (embeddedMode) out.print(" id=\"glyph{{{0}}}\"");
		out.print(" xmlns=\"http://www.w3.org/2000/svg\"");
		out.print(" xmlns:xlink=\"http://www.w3.org/1999/xlink\"");
		if (!embeddedMode) out.print(" version=\"1.1\"");
		if (!embeddedMode) out.print(" width=\"" + w + "\"");
		if (!embeddedMode) out.print(" height=\"" + h + "\"");
		if (!embeddedMode) out.print(" viewBox=\"0 0 " + w + " " + h + "\"");
		out.println(">");
		if (!embeddedMode) out.println("<!-- Generated by Kreative Vexillo v1.0 -->");
		if (!styleBlock.isEmpty()) {
			out.println("<style>");
			for (String line : styleBlock) out.println(line);
			out.println("</style>");
		}
		if (!defsBlock.isEmpty()) {
			out.println("<defs>");
			for (String line : defsBlock) out.println(line);
			out.println("</defs>");
		}
		if (tx != 0 || ty != 0) out.println("<g transform=\"translate(" + tx + " " + ty + ")\">");
		if (embeddedMode) out.println("<g clip-path=\"url(#bounds)\">");
		if (!groupBlock.isEmpty()) {
			out.println("<g>");
			for (String line : groupBlock) out.println(line);
			out.println("</g>");
		}
		if (!glazeBlock.isEmpty()) {
			out.println("<g>");
			for (String line : glazeBlock) out.println(line);
			out.println("</g>");
		}
		if (embeddedMode) out.println("</g>");
		if (tx != 0 || ty != 0) out.println("</g>");
		if (embeddedMode) out.print("</svg>");
		else out.println("</svg>");
	}
	
	private void prep(List<String> styleBlock, List<String> defsBlock) {
		for (Map.Entry<String, Color> e : flag.colors().entrySet()) {
			if (e.getValue() instanceof Color.HasRGB) {
				int rgb = ((Color.HasRGB)e.getValue()).getRGB();
				StringBuffer s = new StringBuffer(".");
				s.append(svgNormalizeId(e.getKey())); s.append("{fill:rgb(");
				s.append((rgb >> 16) & 0xFF); s.append(",");
				s.append((rgb >> 8) & 0xFF); s.append(",");
				s.append(rgb & 0xFF); s.append(");}");
				styleBlock.add(s.toString());
			}
		}
		for (Map.Entry<String, Symbol> e : flag.symbols().entrySet()) {
			StringBuffer s = new StringBuffer("<path id=\"");
			s.append(svgNormalizeId(e.getKey())); s.append("\" d=\"");
			s.append(e.getValue().toString()); s.append("\"/>");
			defsBlock.add(s.toString());
		}
	}
	
	private void execute(Instruction i, Map<String, Dimension> d, List<String> defs, List<String> g, int[] next, boolean clip) {
		if (i instanceof Instruction.GroupInstruction) {
			Instruction.GroupInstruction gi = (Instruction.GroupInstruction)i;
			if (gi.clippingRegion.isEmpty()) {
				g.add("<g>");
				for (Instruction j : gi.instructions) execute(j, d, defs, g, next, clip);
				g.add("</g>");
			} else {
				String clipId = "clip" + (next[CLIP_ID]++);
				List<String> clipPath = new LinkedList<String>();
				clipPath.add("<clipPath id=\"" + clipId + "\">");
				for (Instruction j : gi.clippingRegion) execute(j, d, defs, clipPath, next, true);
				clipPath.add("</clipPath>");
				defs.addAll(clipPath);
				g.add("<g clip-path=\"url(#" + clipId + ")\">");
				for (Instruction j : gi.instructions) execute(j, d, defs, g, next, clip);
				g.add("</g>");
			}
		} else if (i instanceof Instruction.ForInstruction) {
			Instruction.ForInstruction fi = (Instruction.ForInstruction)i;
			g.add("<g>");
			double start = fi.start.value(d);
			double end = fi.end.value(d);
			double step = fi.step.value(d);
			while (start <= end) {
				d.put(fi.var, new Dimension.Constant(start));
				for (Instruction j : fi.instructions) execute(j, d, defs, g, next, clip);
				start += step;
			}
			g.add("</g>");
		} else if (i instanceof Instruction.FieldInstruction) {
			Instruction.FieldInstruction fi = (Instruction.FieldInstruction)i;
			double x1 = fi.x1.value(d);
			double y1 = fi.y1.value(d);
			double x2 = fi.x2.value(d);
			double y2 = fi.y2.value(d);
			g.add(
				"<rect x=\"" + svgRound(x1) + "\" y=\"" + svgRound(y1) + "\"" +
				" width=\"" + svgRound(x2-x1) + "\" height=\"" + svgRound(y2-y1) + "\"" +
				(clip ? "/>" : (" class=\"" + svgNormalizeId(fi.color) + "\"/>"))
			);
		} else if (i instanceof Instruction.HBandInstruction) {
			Instruction.HBandInstruction bi = (Instruction.HBandInstruction)i;
			double x1 = bi.x1.value(d);
			double x2 = bi.x2.value(d);
			double y1 = bi.y1.value(d);
			double height = bi.y2.value(d) - y1;
			if (clip) {
				g.add(
					"<rect x=\"" + svgRound(x1) + "\" y=\"" + svgRound(y1) + "\"" +
					" width=\"" + svgRound(x2-x1) + "\" height=\"" + svgRound(height) + "\"/>"
				);
			} else {
				int currentWeight = 0;
				int totalWeight = bi.getBandWeightTotal();
				g.add("<g>");
				for (int band = 0; band < bi.bands; band++) {
					double bandTop = y1 + height * currentWeight / totalWeight;
					currentWeight += bi.getBandWeight(band);
					double bandBottom = y1 + height * currentWeight / totalWeight;
					String color = bi.getBandColor(band);
					g.add(
						"<rect x=\"" + svgRound(x1) + "\" y=\"" + svgRound(bandTop) + "\"" +
						" width=\"" + svgRound(x2-x1) + "\" height=\"" + svgRound(bandBottom-bandTop) + "\""+
						" class=\"" + svgNormalizeId(color) + "\"/>"
					);
				}
				g.add("</g>");
			}
		} else if (i instanceof Instruction.VBandInstruction) {
			Instruction.VBandInstruction bi = (Instruction.VBandInstruction)i;
			double y1 = bi.y1.value(d);
			double y2 = bi.y2.value(d);
			double x1 = bi.x1.value(d);
			double width = bi.x2.value(d) - x1;
			if (clip) {
				g.add(
					"<rect x=\"" + svgRound(x1) + "\" y=\"" + svgRound(y1) + "\"" +
					" width=\"" + svgRound(width) + "\" height=\"" + svgRound(y2-y1) + "\"/>"
				);
			} else {
				int currentWeight = 0;
				int totalWeight = bi.getBandWeightTotal();
				g.add("<g>");
				for (int band = 0; band < bi.bands; band++) {
					double bandLeft = x1 + width * currentWeight / totalWeight;
					currentWeight += bi.getBandWeight(band);
					double bandRight = x1 + width * currentWeight / totalWeight;
					String color = bi.getBandColor(band);
					g.add(
						"<rect x=\"" + svgRound(bandLeft) + "\" y=\"" + svgRound(y1) + "\"" +
						" width=\"" + svgRound(bandRight-bandLeft) + "\" height=\"" + svgRound(y2-y1) + "\"" +
						" class=\"" + svgNormalizeId(color) + "\"/>"
					);
				}
				g.add("</g>");
			}
		} else if (i instanceof Instruction.CrossInstruction) {
			Instruction.CrossInstruction ci = (Instruction.CrossInstruction)i;
			double x1 = ci.x1.value(d);
			double y1 = ci.y1.value(d);
			double x2 = ci.x2.value(d);
			double y2 = ci.y2.value(d);
			double x3 = ci.x3.value(d);
			double y3 = ci.y3.value(d);
			double x4 = ci.x4.value(d);
			double y4 = ci.y4.value(d);
			g.add("<g>");
			g.add(
				"<rect x=\"" + svgRound(x1) + "\" y=\"" + svgRound(y2) + "\"" +
				" width=\"" + svgRound(x4-x1) + "\" height=\"" + svgRound(y3-y2) + "\"" +
				(clip ? "/>" : (" class=\"" + svgNormalizeId(ci.color) + "\"/>"))
			);
			g.add(
				"<rect x=\"" + svgRound(x2) + "\" y=\"" + svgRound(y1) + "\"" +
				" width=\"" + svgRound(x3-x2) + "\" height=\"" + svgRound(y4-y1) + "\"" +
				(clip ? "/>" : (" class=\"" + svgNormalizeId(ci.color) + "\"/>"))
			);
			g.add("</g>");
		} else if (i instanceof Instruction.SaltireInstruction) {
			Instruction.SaltireInstruction si = (Instruction.SaltireInstruction)i;
			double x1 = si.x1.value(d);
			double y1 = si.y1.value(d);
			double x2 = si.x2.value(d);
			double y2 = si.y2.value(d);
			double thickness = si.thickness.value(d);
			if (thickness < 0.0) thickness = 0.0;
			Stroke stroke = new BasicStroke((float)thickness);
			Area a = new Area(stroke.createStrokedShape(new Line2D.Double(x1, y1, x2, y2)));
			a.add(new Area(stroke.createStrokedShape(new Line2D.Double(x1, y2, x2, y1))));
			a.intersect(new Area(new Rectangle2D.Double(x1, y1, x2 - x1, y2 - y1)));
			String s = shapeToSVG(a);
			g.add(
				"<path d=\"" + s + "\"" +
				(clip ? "/>" : (" class=\"" + svgNormalizeId(si.color) + "\"/>"))
			);
		} else if (i instanceof Instruction.DBandInstruction) {
			Instruction.DBandInstruction bi = (Instruction.DBandInstruction)i;
			double x1 = bi.x1.value(d);
			double y1 = bi.y1.value(d);
			double x2 = bi.x2.value(d);
			double y2 = bi.y2.value(d);
			double thickness = bi.thickness.value(d);
			if (thickness < 0.0) thickness = 0.0;
			Stroke stroke = new BasicStroke((float)thickness, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10);
			Shape sh = stroke.createStrokedShape(new Line2D.Double(x1, y1, x2, y2));
			String s = shapeToSVG(sh);
			g.add(
				"<path d=\"" + s + "\"" +
				(clip ? "/>" : (" class=\"" + svgNormalizeId(bi.color) + "\"/>"))
			);
		} else if (i instanceof Instruction.DiscInstruction) {
			Instruction.DiscInstruction di = (Instruction.DiscInstruction)i;
			double centerX = di.centerX.value(d);
			double centerY = di.centerY.value(d);
			double radiusX = di.width.value(d) / 2.0;
			double radiusY = di.height.value(d) / 2.0;
			double startAngle = di.startAngle.value(d);
			double endAngle = di.endAngle.value(d);
			if (Math.abs(endAngle - startAngle) >= 360.0) {
				g.add(
					"<ellipse cx=\"" + svgRound(centerX) + "\" cy=\"" + svgRound(centerY) + "\"" +
					" rx=\"" + svgRound(radiusX) + "\" ry=\"" + svgRound(radiusY) + "\"" +
					(clip ? "/>" : (" class=\"" + svgNormalizeId(di.color) + "\"/>"))
				);
			} else {
				double x1 = centerX + radiusX * Math.cos(Math.toRadians(startAngle));
				double y1 = centerY - radiusY * Math.sin(Math.toRadians(startAngle));
				double x2 = centerX + radiusX * Math.cos(Math.toRadians(endAngle));
				double y2 = centerY - radiusY * Math.sin(Math.toRadians(endAngle));
				int largeArcFlag = (Math.abs(endAngle - startAngle) >= 180.0) ? 1 : 0;
				int sweepFlag = ((endAngle - startAngle) < 0.0) ? 1 : 0;
				g.add(
					"<path d=\"M " + svgRound(centerX) + " " + svgRound(centerY) +
					" L " + svgRound(x1) + " " + svgRound(y1) +
					" A " + svgRound(radiusX) + " " + svgRound(radiusY) +
					" 0 " + largeArcFlag + " " + sweepFlag +
					" " + svgRound(x2) + " " + svgRound(y2) + " Z\"" +
					(clip ? "/>" : (" class=\"" + svgNormalizeId(di.color) + "\"/>"))
				);
			}
		} else if (i instanceof Instruction.PolyInstruction) {
			Instruction.PolyInstruction pi = (Instruction.PolyInstruction)i;
			StringBuffer s = new StringBuffer();
			for (int idx = 0; idx < pi.points; idx++) {
				double xCoord = pi.x[idx].value(d);
				double yCoord = pi.y[idx].value(d);
				s.append((idx == 0) ? 'M' : 'L'); s.append(' ');
				s.append(svgRound(xCoord)); s.append(' ');
				s.append(svgRound(yCoord)); s.append(' ');
			}
			s.append('Z');
			g.add(
				"<path d=\"" + s.toString() + "\"" +
				(clip ? "/>" : (" class=\"" + svgNormalizeId(pi.color) + "\"/>"))
			);
		} else if (i instanceof Instruction.SymbolInstruction) {
			Instruction.SymbolInstruction si = (Instruction.SymbolInstruction)i;
			double shx = si.x.value(d);
			double shy = si.y.value(d);
			double shsx = si.sx.value(d);
			double shsy = si.sy.value(d);
			double shr = si.rotate.value(d);
			g.add(
				"<use xlink:href=\"#" + svgNormalizeId(si.symbolName) + "\"" +
				" transform=\"translate(" + svgRound(shx) + " " + svgRound(shy) + ")" +
				" scale(" + svgRound(shsx) + " " + svgRound(shsy) + ")" +
				" rotate(" + svgRound(shr) + ")\"" +
				(clip ? "/>" : (" class=\"" + svgNormalizeId(si.color) + "\"/>"))
			);
		} else if (i instanceof Instruction.ImageInstruction) {
			Instruction.ImageInstruction ii = (Instruction.ImageInstruction)i;
			double x1 = ii.x1.value(d);
			double y1 = ii.y1.value(d);
			double x2 = ii.x2.value(d);
			double y2 = ii.y2.value(d);
			if (clip) {
				g.add(
					"<rect x=\"" + svgRound(x1) + "\" y=\"" + svgRound(y1) + "\"" +
					" width=\"" + svgRound(x2-x1) + "\" height=\"" + svgRound(y2-y1) + "\"/>"
				);
			} else {
				String url = getImageDataURL(ii.imageName, "image/svg+xml", "image/svg", "image/png");
				if (url != null) {
					g.add(
						"<image x=\"" + svgRound(x1) + "\" y=\"" + svgRound(y1) + "\"" +
						" width=\"" + svgRound(x2-x1) + "\" height=\"" + svgRound(y2-y1) + "\"" +
						" preserveAspectRatio=\"xMidYMid\" xlink:href=\"" + url + "\"/>"
					);
				}
			}
		} else if (i instanceof Instruction.HGradInstruction) {
			Instruction.HGradInstruction gi = (Instruction.HGradInstruction)i;
			double x1 = gi.x1.value(d);
			double y1 = gi.y1.value(d);
			double x2 = gi.x2.value(d);
			double y2 = gi.y2.value(d);
			if (clip) {
				g.add(
					"<rect x=\"" + svgRound(x1) + "\" y=\"" + svgRound(y1) + "\"" +
					" width=\"" + svgRound(x2-x1) + "\" height=\"" + svgRound(y2-y1) + "\"/>"
				);
			} else {
				Color color1 = flag.colors().get(gi.color1);
				Color color2 = flag.colors().get(gi.color2);
				if (color1 instanceof HasRGB && color2 instanceof HasRGB) {
					String gradId = "grad" + (next[GRAD_ID]++);
					int c1 = ((HasRGB)color1).getRGB();
					int c2 = ((HasRGB)color2).getRGB();
					defs.add("<linearGradient id=\"" + gradId + "\" y1=\"0%\" y2=\"100%\" x1=\"0%\" x2=\"0%\">");
					defs.add("<stop offset=\"0%\" stop-color=\"rgb(" + ((c1 >> 16) & 0xFF) + "," + ((c1 >> 8) & 0xFF) + "," + (c1 & 0xFF) + ")\"/>");
					defs.add("<stop offset=\"100%\" stop-color=\"rgb(" + ((c2 >> 16) & 0xFF) + "," + ((c2 >> 8) & 0xFF) + "," + (c2 & 0xFF) + ")\"/>");
					defs.add("</linearGradient>");
					g.add(
						"<rect x=\"" + svgRound(x1) + "\" y=\"" + svgRound(y1) + "\"" +
						" width=\"" + svgRound(x2-x1) + "\" height=\"" + svgRound(y2-y1) + "\"" +
						" fill=\"url(#" + gradId + ")\"/>"
					);
				}
			}
		} else if (i instanceof Instruction.VGradInstruction) {
			Instruction.VGradInstruction gi = (Instruction.VGradInstruction)i;
			double x1 = gi.x1.value(d);
			double y1 = gi.y1.value(d);
			double x2 = gi.x2.value(d);
			double y2 = gi.y2.value(d);
			if (clip) {
				g.add(
					"<rect x=\"" + svgRound(x1) + "\" y=\"" + svgRound(y1) + "\"" +
					" width=\"" + svgRound(x2-x1) + "\" height=\"" + svgRound(y2-y1) + "\"/>"
				);
			} else {
				Color color1 = flag.colors().get(gi.color1);
				Color color2 = flag.colors().get(gi.color2);
				if (color1 instanceof HasRGB && color2 instanceof HasRGB) {
					String gradId = "grad" + (next[GRAD_ID]++);
					int c1 = ((HasRGB)color1).getRGB();
					int c2 = ((HasRGB)color2).getRGB();
					defs.add("<linearGradient id=\"" + gradId + "\" x1=\"0%\" x2=\"100%\" y1=\"0%\" y2=\"0%\">");
					defs.add("<stop offset=\"0%\" stop-color=\"rgb(" + ((c1 >> 16) & 0xFF) + "," + ((c1 >> 8) & 0xFF) + "," + (c1 & 0xFF) + ")\"/>");
					defs.add("<stop offset=\"100%\" stop-color=\"rgb(" + ((c2 >> 16) & 0xFF) + "," + ((c2 >> 8) & 0xFF) + "," + (c2 & 0xFF) + ")\"/>");
					defs.add("</linearGradient>");
					g.add(
						"<rect x=\"" + svgRound(x1) + "\" y=\"" + svgRound(y1) + "\"" +
						" width=\"" + svgRound(x2-x1) + "\" height=\"" + svgRound(y2-y1) + "\"" +
						" fill=\"url(#" + gradId + ")\"/>"
					);
				}
			}
		}
	}
	
	private void glaze(Map<String, Dimension> d, List<String> defs, List<String> g, int w, int h, int t) {
		double gx = d.containsKey(".glazeleft") ? d.get(".glazeleft").value(d) : 0.0;
		double gy = d.containsKey(".glazetop") ? d.get(".glazetop").value(d) : 0.0;
		double gw = d.containsKey(".glazeright") ? (d.get(".glazeright").value(d) - gx) : (double)w;
		double gh = d.containsKey(".glazebottom") ? (d.get(".glazebottom").value(d) - gy) : (double)h;
		if (gw > 0.0 && gh > 0.0) {
			defs.add("<linearGradient id=\"glaze\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\">");
			defs.add("<stop offset=\"0%\" stop-color=\"rgb(255,255,255)\" stop-opacity=\"0.2\"/>");
			defs.add("<stop offset=\"49.999%\" stop-color=\"rgb(255,255,255)\" stop-opacity=\"0.0\"/>");
			defs.add("<stop offset=\"50.001%\" stop-color=\"rgb(0,0,0)\" stop-opacity=\"0.0\"/>");
			defs.add("<stop offset=\"100%\" stop-color=\"rgb(0,0,0)\" stop-opacity=\"0.2\"/>");
			defs.add("</linearGradient>");
			if (flag.symbols().containsKey(".glazearea")) {
				Shape sh = flag.symbols().get(".glazearea").toPath();
				sh = AffineTransform.getScaleInstance(gw, gh).createTransformedShape(sh);
				sh = AffineTransform.getTranslateInstance(gx, gy).createTransformedShape(sh);
				Shape sh2 = new BasicStroke(t * 2).createStrokedShape(sh);
				Shape sh3 = new BasicStroke(t * 4).createStrokedShape(sh);
				Area outer = new Area(sh); outer.intersect(new Area(sh2));
				Area inner = new Area(sh); inner.intersect(new Area(sh3)); inner.subtract(outer);
				g.add("<path d=\"" + shapeToSVG(sh) + "\" fill=\"url(#glaze)\"/>");
				g.add("<path d=\"" + shapeToSVG(inner) + "\" fill=\"rgb(255,255,255)\" opacity=\"0.4\"/>");
				g.add("<path d=\"" + shapeToSVG(outer) + "\" fill=\"rgb(0,0,0)\" opacity=\"0.4\"/>");
			} else {
				g.add(
					"<rect x=\"" + svgRound(gx) + "\" y=\"" + svgRound(gy) + "\"" +
					" width=\"" + svgRound(gw) + "\" height=\"" + svgRound(gh) + "\"" +
					" fill=\"url(#glaze)\"/>"
				);
				g.add(
					"<path d=\"M " + svgRound(gx+t) + " " + svgRound(gy+t) +
					" L " + svgRound(gx+gw-t) + " " + svgRound(gy+t) +
					" L " + svgRound(gx+gw-t) + " " + svgRound(gy+gh-t) +
					" L " + svgRound(gx+t) + " " + svgRound(gy+gh-t) +
					" Z M " + svgRound(gx+t*2) + " " + svgRound(gy+t*2) +
					" L " + svgRound(gx+t*2) + " " + svgRound(gy+gh-t*2) +
					" L " + svgRound(gx+gw-t*2) + " " + svgRound(gy+gh-t*2) +
					" L " + svgRound(gx+gw-t*2) + " " + svgRound(gy+t*2) +
					" Z\" fill=\"rgb(255,255,255)\" opacity=\"0.4\"/>"
				);
				g.add(
					"<path d=\"M " + svgRound(gx) + " " + svgRound(gy) +
					" L " + svgRound(gx+gw) + " " + svgRound(gy) +
					" L " + svgRound(gx+gw) + " " + svgRound(gy+gh) +
					" L " + svgRound(gx) + " " + svgRound(gy+gh) +
					" Z M " + svgRound(gx+t) + " " + svgRound(gy+t) +
					" L " + svgRound(gx+t) + " " + svgRound(gy+gh-t) +
					" L " + svgRound(gx+gw-t) + " " + svgRound(gy+gh-t) +
					" L " + svgRound(gx+gw-t) + " " + svgRound(gy+t) +
					" Z\" fill=\"rgb(0,0,0)\" opacity=\"0.4\"/>"
				);
			}
		}
	}
	
	private String getImageDataURL(String imageName, String... mimeTypes) {
		if (imageCache.containsKey(imageName)) {
			return imageCache.get(imageName);
		} else if (flag.images().containsKey(imageName)) {
			for (String mimeType : mimeTypes) {
				for (ImageSource src : flag.images().get(imageName)) {
					if (src.type.equalsIgnoreCase(mimeType)) {
						try {
							String s = encodeImageDataURL(src);
							imageCache.put(imageName, s);
							return s;
						} catch (IOException e) {}
					}
				}
			}
			for (ImageSource src : flag.images().get(imageName)) {
				try {
					String s = encodeImageDataURL(src);
					imageCache.put(imageName, s);
					return s;
				} catch (IOException e) {}
			}
		}
		return null;
	}
	
	private String encodeImageDataURL(ImageSource src) throws IOException {
		StringBuffer data = new StringBuffer("data:");
		data.append(src.type); data.append(";base64,");
		OutputStream out = new Base64OutputStream(data);
		InputStream in = src.getInputStream(parent);
		byte[] buf = new byte[1048576]; int len;
		while ((len = in.read(buf)) >= 0) out.write(buf, 0, len);
		in.close(); out.flush(); out.close();
		return data.toString();
	}
	
	private static String svgNormalizeId(String s) {
		return s.replaceAll("[^A-Za-z0-9]+", "-");
	}
	
	private static String svgRound(double v) {
		v = Math.round(v * 10000.0) / 10000.0;
		if (v == (int)v) return Integer.toString((int)v);
		else return Double.toString(v);
	}
	
	private static String shapeToSVG(Shape sh) {
		StringBuffer s = new StringBuffer();
		double[] pts = new double[6];
		for (PathIterator p = sh.getPathIterator(null); !p.isDone(); p.next()) {
			switch (p.currentSegment(pts)) {
			case PathIterator.SEG_MOVETO:
				s.append('M'); s.append(' ');
				s.append(svgRound(pts[0])); s.append(' ');
				s.append(svgRound(pts[1])); s.append(' ');
				break;
			case PathIterator.SEG_LINETO:
				s.append('L'); s.append(' ');
				s.append(svgRound(pts[0])); s.append(' ');
				s.append(svgRound(pts[1])); s.append(' ');
				break;
			case PathIterator.SEG_QUADTO:
				s.append('Q'); s.append(' ');
				s.append(svgRound(pts[0])); s.append(' ');
				s.append(svgRound(pts[1])); s.append(' ');
				s.append(svgRound(pts[2])); s.append(' ');
				s.append(svgRound(pts[3])); s.append(' ');
				break;
			case PathIterator.SEG_CUBICTO:
				s.append('C'); s.append(' ');
				s.append(svgRound(pts[0])); s.append(' ');
				s.append(svgRound(pts[1])); s.append(' ');
				s.append(svgRound(pts[2])); s.append(' ');
				s.append(svgRound(pts[3])); s.append(' ');
				s.append(svgRound(pts[4])); s.append(' ');
				s.append(svgRound(pts[5])); s.append(' ');
				break;
			case PathIterator.SEG_CLOSE:
				s.append('Z'); s.append(' ');
				break;
			}
		}
		return s.toString().trim();
	}
}